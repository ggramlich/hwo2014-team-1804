{
  "name": "CoolBeans",
  "version": "0.0.9",
  "description": "CoolBeans is an Inversion of Control (IOC) / Dependency Injection (DI) library for Node.js. CoolBeans is loosely based on ColdSpring for ColdFusion and Spring IOC for Java.",
  "keywords": [
    "CoolBeans",
    "IOC",
    "Inversion of Control",
    "DI",
    "Dependency Injection",
    "Spring",
    "factory"
  ],
  "homepage": "https://github.com/dhughes/CoolBeans",
  "author": {
    "name": "Doug Hughes",
    "email": "dhughes@alagad.com",
    "url": "http://blog.alagad.com"
  },
  "main": "index",
  "engine": "node >= 0.4.11",
  "repository": {
    "type": "git",
    "url": "https://github.com/dhughes/CoolBeans"
  },
  "readme": "\nCoolBeans is an Inversion of Control (IOC) / Dependency Injection (DI) library for Node.js. CoolBeans is loosely based\non ColdSpring for ColdFusion and Spring IOC for Java.  CoolBeans allows you to decouple your objects from their dependencies.\nIt's a single js file and so-far appears to be quick and easy.\n\nTo install:\n\n\tnpm install CoolBeans\n\nTo use CoolBeans you simply create an instance of the CoolBeans and load the configuration file like this:\n\n\tvar cb = require(\"CoolBeans\");\n\tcb = new cb(\"./config/dev.json\");\n\nThe above code has the only require function you should need in your entire application.  Once you've required CoolBeans\nyou need to create an instance of it and pass in the path to its' configuration.  This is shown above.\n\nOnce you have the fully loaded CoolBeans you can use it to quickly create fully configured singleton objects based on\nits' configuration.  The config file for CoolBeans is a JSON file so the entire thing is wrapped in {}.\n\nEach element in the root of the configuration file is a bean (bean = Java for object) that CoolBeans can create.  Here's an\nexample:\n\n\t{\n\t\t\"fs\": {\"module\": \"fs\"}\n\t}\n\nThis is essentially the same as:\n\n\tvar fs = require(\"fs\");\n\nHowever, we now only need to define this one time for an application, rather than in each file that requires it.\n\nYou can also specify paths to modules that are not node_modules. For example:\n\n\t{\n\t\t\"Recipient\": {\"module\": \"./entities/recipient\"}\n\t}\n\nAt the most basic, the above means that CoolBeans will call require for the module and cache the results in a variable named\nRecipient.\n\nAs a relative newb to Node.js, I think I've handled this correctly.  CoolBeans is a node module which means that NPM\nwill install into ./node_modues/CoolBeans.  The actual CoolBeans script is in the lib directory.  That means, that from\nthe perspective of CoolBeans, your components are three directories above it.  For this reason, CoolBeans looks three\ndirectories above it for the module specified.  So, the Recipient module above actually turns into\n../../.././entities/recipient.  This has the effect of making the paths to modules specified in the configuration file\nrelative to the root of your module or application.  So, if you make a module that depends on CoolBeans and later\npublish it via NPM I think it should work correctly when used in other projects.\n\nYou can get any of the configured beans by calling cb.get(\"beanName\") where beanName is the name of the bean you want\nto get.  For example:\n\n\tcb.get(\"Recipient\");\n\nThe above will lazily create the Recipient bean, cache it as a singleton, and return it.\n\nYou can get a lot more complex with configuration too.  For example, you can specify if CoolBeans should call a constructor\nand what arguments to pass into the constructor.  For example:\n\n\t\"codeGenerator\": {\n\t\t\"module\": \"./util/codeGenerator\",\n\t\t\"constructorArgs\": [\n\t\t\t\"foo\",\n\t\t\t123\n\t\t]\n\t}\n\nWhat the above is saying is that when we get the codeGenerator bean, we need to load the module specified then call\nnew on the module and pass in the values specified in the constructorArgs section to the constructor in the order\nspecified.  The above means:\n\n\tnew codeGenerator(\"foo\", 123);\n\nYou can also write this out to explicitly specify the constructor argument names and values.  For example:\n\n\n\t\"codeGenerator\": {\n\t\t\"module\": \"./util/codeGenerator\",\n\t\t\"constructorArgs\": {\n\t\t\t\"bar\": \"foo\",\n\t\t\t\"blargh\": 123\n\t\t}\n\t}\n\nThis will result in the codeGenerator component being constructed so that the \"bar\" argument is \"foo\" and the \"blargh\"\nargument is 123.  These do not need to be specified in order.  This is particularly  convenient when some arguments are\noptional.\n\nYou can also specify more complex values to pass into constructor arguments:\n\n\t\"codeGenerator\": {\n\t\t\"module\": \"./util/codeGenerator\",\n\t\t\"constructorArgs\": [\n\t\t\t\"foo\",\n\t\t\t123,\n\t\t\t{\"value\": [1, 2, 3]},\n\t\t\t{\"value\":\n\t\t\t\t{\n\t\t\t\t\t\"foo\": \"bar\",\n\t\t\t\t\t\"bar\": \"foo\"\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t}\n\nNote that while you can specify a string, number, or null without indicating explicitly it's a \"value\", for arrays and\nanonymous objects you need to provide an object with a property named \"value\" whose value is the value you're trying to\npass in.  The above could be written more explicitly as:\n\n\t\"codeGenerator\": {\n\t\t\"module\": \"./util/codeGenerator\",\n\t\t\"constructorArgs\": [\n\t\t\t{\"value\": \"foo\"},\n\t\t\t{\"value\": 123},\n\t\t\t{\"value\": [1, 2, 3]},\n\t\t\t{\"value\":\n\t\t\t\t{\n\t\t\t\t\t\"foo\": \"bar\",\n\t\t\t\t\t\"bar\": \"foo\"\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t}\n\nAnd again, if you wanted to specify the names of the arguments on the constructor you could also write it as:\n\n\t\"codeGenerator\": {\n\t\t\"module\": \"./util/codeGenerator\",\n\t\t\"constructorArgs\": {\n\t\t\t\"bar\": {\"value\": \"foo\"},\n\t\t\t\"blargh\": {\"value\": 123},\n\t\t\t\"someArray\": {\"value\": [1, 2, 3]},\n\t\t\t\"someObject\": {\"value\":\n\t\t\t\t{\n\t\t\t\t\t\"foo\": \"bar\",\n\t\t\t\t\t\"bar\": \"foo\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nStrings, numbers, arrays, and anonymous objects are not the only things you can pass into constructors.  You can also\nspecify other beans that could be passed in.  For example, let's say we had a database configuration object you want to\npass into any object that is used to access data you could do the following:\n\n\t\"mysql\": {\"module\": \"mysql\"},\n\t\n\t\"dbConfig\": {\n\t\t\"properties\": {\n\t\t\t\"host\": \"server.hostname.com\",\n\t\t\t\"port\": 3306,\n\t\t\t\"user\": \"mysqlUser\",\n\t\t\t\"password\": \"password123\",\n\t\t\t\"database\": \"foobar\"\n\t\t}\n\t},\n\t\n\t\"recipientDao\": {\n\t\t\"module\": \"./db/recipientDao\",\n\t\t\"constructorArgs\": [\n\t\t\t{\"bean\": \"dbConfig\"},\n\t\t\t{\"bean\": \"mysql\"}\n\t\t]\n\t}\n\nThe mysql bean is simply the same as saying require(\"mysql\").  The dbConfig is an anonymous object with properties\nspecified (more on this in a bit).  When the recipientDao (dao = data access object) is created, CoolBeans will see the\n\"bean\" property and will create and pass into the constructor the fully-constructed dbConfig object and the mysql\nobject. Here's what that recipientDao might look like:\n\n\tmodule.exports = function(dbConfig, mysql){\n\t\n\t\tthis.listRecipients = function(userId, callback){\n\t\t\tvar client = mysql.createClient(dbConfig);\n\t\t\tclient.query(\n\t\t\t\t\"SELECT id, name, addressLine1, IfNull(addressLine2, '') as addressLine2, city, state, zip, taxDeductible, created, updated, 0 as netDonations \" +\n\t\t\t\t\"FROM recipient \" +\n\t\t\t\t\"WHERE userId = ? AND deleted = 0 \"+\n\t\t\t\t\"ORDER BY name\",\n\t\t\t[userId],\n\t\t\tfunction(err, results, fields){\n\t\t\t\tclient.end();\n\t\t\t\tcallback(results);\n\t\t\t});\n\t\t}\n\t}\n\nNote that there are no require statements.  The object just gets its' dependencies when it's instantiated and can\nimmediately use them.  These dependencies are also automatically singletons.\n\nIf you want to use a transient object you would still create an instance of it the way you always have.\n\nI also mentioned above that CoolBeans can be used to create create and populate anonymous objects.  For example:\n\n\t\"dbConfig\": {\n\t\t\"properties\": {\n\t\t\t\"host\": \"server.hostname.com\",\n\t\t\t\"port\": 3306,\n\t\t\t\"user\": \"mysqlUser\",\n\t\t\t\"password\": \"password123\",\n\t\t\t\"database\": \"foobar\"\n\t\t}\n\t}\n\nThis is a somewhat long-winded way of saying\n\n\tdbConfig = {\n\t\t\"host\": \"server.hostname.com\",\n\t\t\"port\": 3306,\n\t\t\"user\": \"mysqlUser\",\n\t\t\"password\": \"password123\",\n\t\t\"database\": \"foobar\"\n\t};\n\nHowever, once this object is configured in CoolBeans you can easily pass it into other objects when they are created.\n\nYou can also specify properties for not-anonymous objects. You can also mix and match constructorArgs and properties.\nFor example:\n\n\t\"creditCardDao\": {\n\t\t\"module\": \"./db/creditCardDao\",\n\t\t\"constructorArgs\": [\n\t\t\t{\"bean\": \"dbConfig\"},\n\t\t\t{\"bean\": \"authorize\"},\n\t\t\t{\"bean\": \"mysql\"},\n\t\t\t{\"bean\": \"CreditCard\"}\n\t\t],\n\t\t\"properties\": {\n\t\t\t\"service\": {\"bean\": \"service\"}\n\t\t}\n\t}\n\nWhen CoolBeans creates the creditCardDao it will first create all the beans specified in the constructorArgs. It will then\ncreate the creditCardDao and pass in the four already-created beans to the constructor.  Once the object is constructed\nit will set the service property on the object to the specified service bean.  Note, CoolBeans will look for a setter and use\nthat if it can find it.  For example, in the service property above, CoolBeans will first look for a function named setservice (note\nthat this is case sensitive).  If it can find it, it will pass in the service bean to that function.  If not, it will\nsimply set a public property on the object.\n\nThere are a few other interesting capabilities of CoolBeans:\n\nBeans don't have to be lazily loaded.  You can set a bean to load when the container loads.  For example:\n\n\t\"dateFormat\": {\n\t\t\"module\": \"./util/dateFormat\",\n\t\t\"lazy\": false\n\t}\n\nAlso, if you have a factory that is used to construct other objects, you can specify this using the factoryBean and\nfactoryMethod properties.  For example:\n\n\t\"knox\": {\"module\": \"knox\"},\n\t\n\t\"s3client\": {\n\t\t\"factoryBean\": \"knox\",\n\t\t\"factoryMethod\": \"createClient\",\n\t\t\"constructorArgs\": [\n\t\t\t{\"value\":\n\t\t\t\t{\n\t\t\t\t\t\"key\": \"myKey\",\n\t\t\t\t\t\"secret\": \"mySecret\",\n\t\t\t\t\t\"bucket\": \"myBucket\"\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t}\n\nThe above s3client bean is configured so CoolBeans uses knox to create it.  The constructor args are passed into the\nfactoryMethod as if it were a constructor.  The above essentially boils down to:\n\n\ts3client = knox.createClient({\n\t\t\"key\": \"myKey\",\n\t\t\"secret\": \"mySecret\",\n\t\t\"bucket\": \"myBucket\"\n\t});\n\nAlso, if you have a function that is used to construct other objects, you can specify this using the factoryBean property.  For example:\n\n\t\"express\" : {\n        \"module\" : \"express\"\n    },\n    \"app\" : {\n        \"factoryBean\" : \"express\"\n    },\n\nThe above app bean is configured so CoolBeans uses express to create it.  The above essentially boils down to:\n\n    var express = require('express');\n\tvar app = express();\n\nVersion 0.0.8 or CoolBeans introduced autowiring.  Autowiring can be used so that you don't have to explicitly specify\nconstructor args or property values.  Consider this example from above:\n\n\t\"creditCardDao\": {\n\t\t\"module\": \"./db/creditCardDao\",\n\t\t\"constructorArgs\": [\n\t\t\t{\"bean\": \"dbConfig\"},\n\t\t\t{\"bean\": \"authorize\"},\n\t\t\t{\"bean\": \"mysql\"},\n\t\t\t{\"bean\": \"CreditCard\"}\n\t\t],\n\t\t\"properties\": {\n\t\t\t\"service\": {\"bean\": \"service\"}\n\t\t}\n\t}\n\nThis could be rewritten as such:\n\n\n\t\"creditCardDao\": {\n\t\t\"module\": \"./db/creditCardDao\",\n\t\t\"autowire\": true\n\t}\n\nNow, when CoolBeans creates an instance of the creditCardDao bean it will assume the object needs to be constructed.  It\nwill introspect the constructor and find out that it has the following arguments: dbConfig, authorize, mysql, and CreditCard.  \nAutowiring will make CoolBeans look to see if it has beans defined that have the same exact name.  If so, these will be \npassed in as those constructor args.  \n\nThis also works for properties.  CoolBeans will look at all the public elements in creditCardDao. If any of them exactly\nmatch a bean defined in CoolBeans then that bean will be set into that element.  For example, the creditCardDao may\ndefine the service property like so:\n\n\tmodule.exports = function(dbConfig, authorize, mysql, CreditCard){\n\t\tthis.service = null;\n\t}\n\nCoolBeans will see the service property, look for a bean named \"service\", and, if it's found set the service property\nto the service bean.\n\nNote that for CoolBeans to find this property it must have a value.  If the property is undefined it can't be found. For\nexample, the following will not work with CoolBeans:\n\n\tmodule.exports = function(dbConfig, authorize, mysql, CreditCard){\n\t\tthis.service;\n\t}\n\nThis.service is undefined and therefore can't be \"seen\" outside the bean and CoolBeans will ignore it.\n\nYou can also set setters using CoolBeans.  The service property can also be set using code like this:\n\n\tmodule.exports = function(dbConfig, authorize, mysql, CreditCard){\n\n\t\tvar _service;\n\n\t\tthis.setservice = function(service){\n\t\t\t_service = service;\n\t\t}\n\t}\n\nThe setservice function will be seen by CoolBeans and the service object will be passed into it. Note that CoolBeans (like\nthe rest of JavaScript) is case sensitive.  You can't specify a function named setService and hope that a bean named \"service\"\nwould be passed into it.\n\nThe really nice thing about CoolBeans is that it lets the objects in your system stay focused on what they do best.  It\nshouldn't be your object's responsibility to know what they need to work.  They should simply get what they need to work\nwhen they're created.  CoolBeans also helps avoid situations in complex apps where you have dozens of lines of code just\ngetting dependencies created just to create one object that otherwise happens to have a lot of dependencies. Lastly, CoolBeans\nallows you to easily change how your application is configured in different environments.\n\n",
  "readmeFilename": "README.md",
  "_id": "CoolBeans@0.0.9",
  "_from": "CoolBeans@"
}
